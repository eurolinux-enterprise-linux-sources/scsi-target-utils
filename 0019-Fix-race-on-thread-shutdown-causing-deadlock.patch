From f14e5898ada8c3090e889755d48a8e476ae84b2c Mon Sep 17 00:00:00 2001
From: Andy Grover <agrover@redhat.com>
Date: Mon, 28 Apr 2014 18:51:20 -0700
Subject: [PATCH] Fix race on thread shutdown causing deadlock

This patch and the next are somewhat a revert of 318e9f2, but the previous
fix didn't quite close the race. This only happens when we create threads
for a backstore that turns out to be invalid, which we then tear down.

See https://bugzilla.redhat.com/show_bug.cgi?id=848585 .

This is occurring because there's still a window where a thread misses
seeing info->stop == 1 but is not yet in cond_wait so it misses the
broadcast:

thread_close:              thread_worker_fn:
                           info->stop is seen as 0
info->stop = 1
pthread_cond_broadcast     -- misses broadcast
                           pthread_cond_wait
pthread_join (hangs)

I believe the solution is to go back to using pthread_cancel. We can call
it before pthread_cond_wait is called (or after) and it will do the right
thing: pop out and exit. The only tricky bit is we need to use the
pthread_cleanup_push mechanism to properly release info->pending_lock.

Remove startup_lock

The purpose of the startup lock was to hold threads at the startup_lock
so if a thread creation fails, it's still possible to have them
end themselves by looking at info->stop. Since we are back to using
pthread_cancel instead of info->stop, we don't need this any more.
The only wrinkle is we need to only send pthread_cancels to
successfully-created threads, so now check this in the destroy_threads
reverse-loop.

Replace if()/goto with while()

Is equivalent and nicer-looking.

Remove unneeded pthread_cond_broadcast

Previous patchset neglected to remove a now unneeded call.

Signed-off-by: Andy Grover <agrover@redhat.com>
---
 usr/bs.c        | 57 +++++++++++++++++++++++----------------------------------
 usr/bs_thread.h |  4 ----
 2 files changed, 23 insertions(+), 38 deletions(-)

diff --git a/usr/bs.c b/usr/bs.c
index e56e450..6ead9f3 100644
--- a/usr/bs.c
+++ b/usr/bs.c
@@ -89,11 +89,9 @@ retry:
 	}
 
 	pthread_mutex_lock(&finished_lock);
-retest:
-	if (list_empty(&finished_list)) {
+
+	while (list_empty(&finished_list))
 		pthread_cond_wait(&finished_cond, &finished_lock);
-		goto retest;
-	}
 
 	while (!list_empty(&finished_list)) {
 		cmd = list_first_entry(&finished_list,
@@ -180,6 +178,12 @@ static void bs_sig_request_done(int fd, int events, void *data)
 	}
 }
 
+/* Unlock mutex even if thread is cancelled */
+static void mutex_cleanup(void *mutex)
+{
+	pthread_mutex_unlock(mutex);
+}
+
 static void *bs_thread_worker_fn(void *arg)
 {
 	struct bs_thread_info *info = arg;
@@ -189,27 +193,19 @@ static void *bs_thread_worker_fn(void *arg)
 	sigfillset(&set);
 	sigprocmask(SIG_BLOCK, &set, NULL);
 
-	pthread_mutex_lock(&info->startup_lock);
-	dprintf("started this thread\n");
-	pthread_mutex_unlock(&info->startup_lock);
-
-	while (!info->stop) {
+	while (1) {
 		pthread_mutex_lock(&info->pending_lock);
-	retest:
-		if (list_empty(&info->pending_list)) {
-			pthread_cond_wait(&info->pending_cond, &info->pending_lock);
-			if (info->stop) {
-				pthread_mutex_unlock(&info->pending_lock);
-				pthread_exit(NULL);
-			}
-			goto retest;
-		}
+		pthread_cleanup_push(mutex_cleanup, &info->pending_lock);
+
+		while (list_empty(&info->pending_list))
+			pthread_cond_wait(&info->pending_cond,
+					  &info->pending_lock);
 
 		cmd = list_first_entry(&info->pending_list,
 				       struct scsi_cmd, bs_list);
 
 		list_del(&cmd->bs_list);
-		pthread_mutex_unlock(&info->pending_lock);
+		pthread_cleanup_pop(1); /* Unlock pending_lock mutex */
 
 		info->request_fn(cmd);
 
@@ -339,9 +335,7 @@ int bs_thread_open(struct bs_thread_info *info, request_func_t *rfn,
 
 	pthread_cond_init(&info->pending_cond, NULL);
 	pthread_mutex_init(&info->pending_lock, NULL);
-	pthread_mutex_init(&info->startup_lock, NULL);
 
-	pthread_mutex_lock(&info->startup_lock);
 	for (i = 0; i < nr_threads; i++) {
 		ret = pthread_create(&info->worker_thread[i], NULL,
 				     bs_thread_worker_fn, info);
@@ -353,22 +347,21 @@ int bs_thread_open(struct bs_thread_info *info, request_func_t *rfn,
 				goto destroy_threads;
 		}
 	}
-	pthread_mutex_unlock(&info->startup_lock);
 	info->nr_worker_threads = nr_threads;
 
 	return 0;
 destroy_threads:
-	info->stop = 1;
 
-	pthread_mutex_unlock(&info->startup_lock);
 	for (; i > 0; i--) {
-		pthread_join(info->worker_thread[i - 1], NULL);
-		eprintf("stopped the worker thread %d\n", i - 1);
+		if (info->worker_thread[i - 1]) {
+			pthread_cancel(info->worker_thread[i - 1]);
+			pthread_join(info->worker_thread[i - 1], NULL);
+			eprintf("stopped the worker thread %d\n", i - 1);
+		}
 	}
 
 	pthread_cond_destroy(&info->pending_cond);
 	pthread_mutex_destroy(&info->pending_lock);
-	pthread_mutex_destroy(&info->startup_lock);
 	free(info->worker_thread);
 
 	return TGTADM_NOMEM;
@@ -378,18 +371,14 @@ void bs_thread_close(struct bs_thread_info *info)
 {
 	int i;
 
-	info->stop = 1;
-	pthread_cond_broadcast(&info->pending_cond);
-
-	for (i = 0; info->worker_thread[i] && i < info->nr_worker_threads; i++)
+	for (i = 0; i < info->nr_worker_threads && info->worker_thread[i]; i++) {
+		pthread_cancel(info->worker_thread[i]);
 		pthread_join(info->worker_thread[i], NULL);
+	}
 
 	pthread_cond_destroy(&info->pending_cond);
 	pthread_mutex_destroy(&info->pending_lock);
-	pthread_mutex_destroy(&info->startup_lock);
 	free(info->worker_thread);
-
-	info->stop = 0;
 }
 
 int bs_thread_cmd_submit(struct scsi_cmd *cmd)
diff --git a/usr/bs_thread.h b/usr/bs_thread.h
index 50dd1c3..b282b17 100644
--- a/usr/bs_thread.h
+++ b/usr/bs_thread.h
@@ -11,10 +11,6 @@ struct bs_thread_info {
 	/* protected by pending_lock */
 	struct list_head pending_list;
 
-	pthread_mutex_t startup_lock;
-
-	int stop;
-
 	request_func_t *request_fn;
 };
 
-- 
1.9.0

